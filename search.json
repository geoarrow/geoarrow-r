[{"path":"https://paleolimbot.github.io/geoarrow/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 geoarrow authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"inspecting-the-data-from-r","dir":"Articles","previous_headings":"","what":"Inspecting the data from R","title":"C and C++ development guide","text":"easiest way inspect geoarrow array data R using wk package. general structure array available wk::wk_vector_meta(), fast (doesn’t iterate points). need geodesic flag CRS, can use wk::wk_is_geoesic() wk::wk_crs(): can access coordinate values flat arrays using wk_coords(): need geoarrow/arrow-specific metadata information, can inspect schemas directly using list-like interface schem aobjects. important thing check extension name, tell bit compiled code need safely access array data. points, also check dimensions storage type, since depending dimensions /encoding underlying arrays buffer numbers /types. output indicates point array fixed-size list (size 2) whose child float64. dimension output indicates dimension type xy. may also need access extension metadata contains information like CRS. metadata serialized raw schema, ’ll need geoarrow_metadata() extract .","code":"wk::wk_vector_meta(points) #>   geometry_type size has_z has_m #> 1             1    2 FALSE FALSE wk::wk_is_geodesic(points) #> [1] FALSE wk::wk_crs(points) #> NULL wk::wk_coords(linestrings) #>   feature_id part_id ring_id  x  y #> 1          1       1       0 30 10 #> 2          1       1       0 10 30 #> 3          1       1       0 40 40 #> 4          2       2       0  0  0 #> 5          2       2       0 10  5 points$schema$metadata[[\"ARROW:extension:name\"]] #> [1] \"geoarrow.point\" points$schema$format #> [1] \"+w:2\" points$schema$children[[1]]$format #> [1] \"g\" points$schema$children[[1]]$name #> [1] \"xy\" geoarrow_metadata(points$schema) #> named list()"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"inspecting-the-data-using-geoarrow-hpp","dir":"Articles","previous_headings":"","what":"Inspecting the data using geoarrow.hpp","title":"C and C++ development guide","text":"(TODO…write !)","code":""},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"inspecting-the-data-from-c","dir":"Articles","previous_headings":"","what":"Inspecting the data from C","title":"C and C++ development guide","text":"need deal arbitrary vectors may different types different point encodings, #include \"geoarrow.hpp\" use helper functions provided ; however, geoarrow format designed accessible C code without helpers. can make assumptions geometry type storage type input still want speed compiled code, using C structures directly may good fit. easiest way inspect schema, encodes storage type extra geo-specific extension metadata, drop C. particular, wk::wk_vector_meta() implemented geoarrow arrays way (1) validate schema let make stronger assumptions C structures given (2) deserialize extract metadata might need reduce number problems solve C. really need compiled code, can access struct ArrowSchema directly. example, extract dimensions C, can : ’re R, preferred approach extract information need wk::wk_vector_meta(), since also validate schema (making can write compact compiled code assumes valid structure). Now ’ve inspected metadata, can move data! Accessing coordinates things whole reason ’re …let’s get ! example, ’m going print coordinates information containing structures.","code":"#include <R.h> #include \"narrow.h\"  SEXP c_point_dimensions(SEXP schema_xptr) {   struct ArrowSchema* schema = schema_from_xptr(schema_xptr, \"schema\");   return Rf_mkString(schema->children[0]->name); } .Call(\"c_point_dimensions\", points$schema) #> [1] \"xy\" .Call(\"c_point_dimensions\", linestrings$schema$children[[1]]) #> [1] \"xy\""},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"points","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Points","title":"C and C++ development guide","text":"points encoded fixed-size list (default), need three pieces information: length, initial offset array, buffer doubles containing coordinates. need validate least much schema advance: points encoded struct, approach similar one buffer per dimension required. need validate least much advance:","code":"stopifnot(   points$schema$format == \"+w:2\",   points$schema$children[[1]]$format == \"g\" ) #include <R.h> #include \"narrow.h\"  SEXP c_point_print(SEXP array_data_xptr) {   struct ArrowArray* array_data = array_data_from_xptr(array_data_xptr, \"array_data\");      int coord_size = 2;   double* coords = (double*) array_data->children[0]->buffers[1];   coords = coords + (array_data->offset) * coord_size;    double* coord;   for (int64_t i = 0; i < array_data->length; i++) {     coord = coords + (i * coord_size);     Rprintf(\"point[%d] (%g %g)\\n\", i, coord[0], coord[1]);   }      return R_NilValue; } invisible(.Call(\"c_point_print\", points$array_data)) #> point[0] (30 10) #> point[1] (40 30) points_struct <- geoarrow_create(   points,   schema = geoarrow_schema_point_struct() )  stopifnot(   points_struct$schema$format == \"+s\",   points_struct$schema$children[[1]]$format == \"g\",   points_struct$schema$children[[2]]$format == \"g\" ) #include <R.h> #include \"narrow.h\"  SEXP c_point_struct_print(SEXP array_data_xptr) {   struct ArrowArray* array_data = array_data_from_xptr(array_data_xptr, \"array_data\");      double* x = (double*) array_data->children[0]->buffers[1];   double* y = (double*) array_data->children[1]->buffers[1];   x = x + array_data->offset;   y = y + array_data->offset;    for (int64_t i = 0; i < array_data->length; i++) {     Rprintf(\"point[%d] (%g %g)\\n\", i, x[i], y[i]);   }      return R_NilValue; } invisible(.Call(\"c_point_struct_print\", points_struct$array_data)) #> point[0] (30 10) #> point[1] (40 30)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"linestrings","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Linestrings","title":"C and C++ development guide","text":"addition information point, also need offsets point array outer linestring. Just like point, ’ll need validate things array handed avoid segfault.","code":"stopifnot(   linestrings$schema$format == \"+l\",   linestrings$schema$children[[1]]$format == \"+w:2\",   linestrings$schema$children[[1]]$children[[1]]$format == \"g\" ) #include <R.h> #include \"narrow.h\"  SEXP c_linestring_print(SEXP array_data_xptr) {   struct ArrowArray* array_data = array_data_from_xptr(array_data_xptr, \"array_data\");      int coord_size = 2;   double* coords = (double*) array_data->children[0]->children[0]->buffers[1];   int32_t* coord_offsets = (int32_t*) array_data->buffers[1];      coord_offsets = coord_offsets + array_data->offset;   coords = coords + coord_offsets[0];    double* coord;   for (int64_t i = 0; i < array_data->length; i++) {     int32_t n_coords = coord_offsets[i + 1] - coord_offsets[i];          for (int32_t j = 0; j < n_coords; j++) {       coord = coords + coord_size * (coord_offsets[i] + j);       Rprintf(\"linestring[%d]->point[%d] (%g %g)\\n\", i, j, coord[0], coord[1]);     }   }      return R_NilValue; } invisible(.Call(\"c_linestring_print\", linestrings$array_data)) #> linestring[0]->point[0] (30 10) #> linestring[0]->point[1] (10 30) #> linestring[0]->point[2] (40 40) #> linestring[1]->point[0] (0 0) #> linestring[1]->point[1] (10 5)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"polygons","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Polygons","title":"C and C++ development guide","text":"addition information linestring, also need offsets rings array outer polygon ’ll need validate outer layer addition bits validated inner arrays.","code":"stopifnot(   polygons$schema$format == \"+l\",   polygons$schema$children[[1]]$format == \"+l\",   polygons$schema$children[[1]]$children[[1]]$format == \"+w:2\",   polygons$schema$children[[1]]$children[[1]]$children[[1]]$format == \"g\" ) #include <R.h> #include \"narrow.h\"  SEXP c_polygon_print(SEXP array_data_xptr) {   struct ArrowArray* array_data = array_data_from_xptr(array_data_xptr, \"array_data\");      int coord_size = 2;   double* coords = (double*) array_data->children[0]->children[0]->children[0]->buffers[1];   int32_t* coord_offsets = (int32_t*) array_data->children[0]->buffers[1];   int32_t* ring_offsets = (int32_t*) array_data->buffers[1];      ring_offsets = ring_offsets + array_data->offset;   coord_offsets = coord_offsets + ring_offsets[0];   coords = coords + coord_offsets[0];    double* coord;   int32_t* coord_offset;   for (int64_t i = 0; i < array_data->length; i++) {     int32_t n_seq = ring_offsets[i + 1] - ring_offsets[i];     coord_offset = coord_offsets + ring_offsets[i];               for (int32_t j = 0; j < n_seq; j++) {       int32_t n_coords = coord_offset[j + 1] - coord_offset[j];              for (int32_t k = 0; k < n_coords; k++) {         coord = coords + (coord_size * (coord_offset[j] + k));         Rprintf(           \"polygon[%d]->ring[%d]->point[%d] (%g %g)\\n\",           i, j, k, coord[0], coord[1]);       }     }   }      return R_NilValue; } invisible(.Call(\"c_polygon_print\", polygons$array_data)) #> polygon[0]->ring[0]->point[0] (30 10) #> polygon[0]->ring[0]->point[1] (40 40) #> polygon[0]->ring[0]->point[2] (20 40) #> polygon[0]->ring[0]->point[3] (10 20) #> polygon[0]->ring[0]->point[4] (30 10) #> polygon[1]->ring[0]->point[0] (35 10) #> polygon[1]->ring[0]->point[1] (45 45) #> polygon[1]->ring[0]->point[2] (15 40) #> polygon[1]->ring[0]->point[3] (10 20) #> polygon[1]->ring[0]->point[4] (35 10) #> polygon[1]->ring[1]->point[0] (20 30) #> polygon[1]->ring[1]->point[1] (35 35) #> polygon[1]->ring[1]->point[2] (30 20) #> polygon[1]->ring[1]->point[3] (20 30)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"multipoints","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Multipoints","title":"C and C++ development guide","text":"Iterating multipoints requires code assertions linestrings:","code":"invisible(.Call(\"c_linestring_print\", multipoints$array_data)) #> linestring[0]->point[0] (0 1) #> linestring[0]->point[1] (2 3) #> linestring[1]->point[0] (0 0) #> linestring[1]->point[1] (3 8)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"multilinestrings","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Multilinestrings","title":"C and C++ development guide","text":"Iterating multilinestrings requires code assertions polygons:","code":"invisible(.Call(\"c_polygon_print\", multilinestrings$array_data)) #> polygon[0]->ring[0]->point[0] (30 10) #> polygon[0]->ring[0]->point[1] (40 40) #> polygon[0]->ring[0]->point[2] (20 40) #> polygon[0]->ring[0]->point[3] (10 20) #> polygon[0]->ring[0]->point[4] (30 10) #> polygon[1]->ring[0]->point[0] (35 10) #> polygon[1]->ring[0]->point[1] (45 45) #> polygon[1]->ring[0]->point[2] (15 40) #> polygon[1]->ring[0]->point[3] (10 20) #> polygon[1]->ring[0]->point[4] (35 10) #> polygon[1]->ring[1]->point[0] (20 30) #> polygon[1]->ring[1]->point[1] (35 35) #> polygon[1]->ring[1]->point[2] (30 20) #> polygon[1]->ring[1]->point[3] (20 30)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/development.html","id":"multipolygons","dir":"Articles","previous_headings":"Inspecting the data from C","what":"Multipolygons","title":"C and C++ development guide","text":"addition information polygon, also need offsets geometries array outer collection. ’ll need validate outer layer addition bits validated inner arrays.","code":"stopifnot(   multipolygons$schema$format == \"+l\",   multipolygons$children[[1]]$schema$format == \"+l\",   multipolygons$children[[1]]$schema$children[[1]]$format == \"+l\",   multipolygons$children[[1]]$schema$children[[1]]$children[[1]]$format == \"+w:2\",   multipolygons$children[[1]]$schema$children[[1]]$children[[1]]$children[[1]]$format == \"g\" ) #include <R.h> #include \"narrow.h\"  SEXP c_multipolygon_print(SEXP array_data_xptr) {   struct ArrowArray* array_data = array_data_from_xptr(array_data_xptr, \"array_data\");      int coord_size = 2;   double* coords = (double*) array_data->children[0]->children[0]->children[0]->children[0]->buffers[1];   int32_t* coord_offsets = (int32_t*) array_data->children[0]->children[0]->buffers[1];   int32_t* ring_offsets = (int32_t*) array_data->children[0]->buffers[1];   int32_t* geom_offsets = (int32_t*) array_data->buffers[1];      geom_offsets = geom_offsets + array_data->offset;   ring_offsets = ring_offsets + geom_offsets[0];   coord_offsets = coord_offsets + ring_offsets[0];   coords = coords + coord_offsets[0];    double* coord;   int32_t* coord_offset;   int32_t* ring_offset;   for (int64_t i = 0; i < array_data->length; i++) {     int32_t n_geoms = geom_offsets[i + 1] - geom_offsets[i];     ring_offset = ring_offsets + geom_offsets[i];          for (int32_t j = 0; j < n_geoms; j++) {       int32_t n_rings = ring_offset[j + 1] - ring_offset[j];       coord_offset = coord_offsets + ring_offsets[j];                     for (int32_t k = 0; k < n_rings; k++) {         int32_t n_coords = coord_offset[k + 1] - coord_offset[k];                  for (int32_t l = 0; l < n_coords; l++) {           coord = coords + (coord_size * (coord_offset[k] + l));           Rprintf(             \"multipolygon[%d]->polygon[%d]->ring[%d]->point[%d] (%g %g)\\n\",             i, j, k, l, coord[0], coord[1]);         }       }     }    }      return R_NilValue; } invisible(.Call(\"c_multipolygon_print\", multipolygons$array_data)) #> multipolygon[0]->polygon[0]->ring[0]->point[0] (30 20) #> multipolygon[0]->polygon[0]->ring[0]->point[1] (45 40) #> multipolygon[0]->polygon[0]->ring[0]->point[2] (10 40) #> multipolygon[0]->polygon[0]->ring[0]->point[3] (30 20) #> multipolygon[0]->polygon[1]->ring[0]->point[0] (15 5) #> multipolygon[0]->polygon[1]->ring[0]->point[1] (40 10) #> multipolygon[0]->polygon[1]->ring[0]->point[2] (10 20) #> multipolygon[0]->polygon[1]->ring[0]->point[3] (5 10) #> multipolygon[0]->polygon[1]->ring[0]->point[4] (15 5) #> multipolygon[1]->polygon[0]->ring[0]->point[0] (30 20) #> multipolygon[1]->polygon[0]->ring[0]->point[1] (45 40) #> multipolygon[1]->polygon[0]->ring[0]->point[2] (10 40) #> multipolygon[1]->polygon[0]->ring[0]->point[3] (30 20) #> multipolygon[1]->polygon[1]->ring[0]->point[0] (15 5) #> multipolygon[1]->polygon[1]->ring[0]->point[1] (40 10) #> multipolygon[1]->polygon[1]->ring[0]->point[2] (10 20) #> multipolygon[1]->polygon[1]->ring[0]->point[3] (5 10) #> multipolygon[1]->polygon[1]->ring[0]->point[4] (15 5) #> multipolygon[1]->polygon[1]->ring[1]->point[0] (40 40) #> multipolygon[1]->polygon[1]->ring[1]->point[1] (20 45) #> multipolygon[1]->polygon[1]->ring[1]->point[2] (45 30) #> multipolygon[1]->polygon[1]->ring[1]->point[3] (40 40)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"metadata","dir":"Articles","previous_headings":"","what":"Metadata","title":"Geometry storage formats in geoarrow","text":"geoarrow arrays carry extension type “geoarrow.” prefix (via field-level ARROW:extension:name metadata key) extension metadata (via field-level ARROW:extension:metadata key). extension metadata contains key/value pairs encoded format specified metadata C data interface. format chosen allow readers access information without vendor base64 decoder JSON parser. Currently supported keys : crs: Contains serialized version coordinate reference system one CRS formats recognized PROJ engine (.e., proj_create_crs_to_crs() C API projinfo -k crs command-line). crs key omitted crs unknown (.e., empty string used). WKT2 AUTHORITY:CODE formats preferred. sufficient, AUTHORITY:CODE used easier test equality another CRS. Values crs key authority compliant possible (.e., OGC:CRS84 used place EPSG:4326 unless latitude values stored longitude values). string interpreted using UTF-8 encoding. geodesic: value \"true\" instructs readers edges interpolated along ellipsoidal path rather Cartesian one (.e., lossless conversion S2 /BigQuery geography. geodesic key must \"true\" key omitted. keys appear order listed . Empty metadata encoded four zero bytes (.e., 32-bit integer 0x00 0x00 0x00 0x00, indicating zero metadata keys) rather omitted. constraints place ensure type equality can checked without deserializing ARROW:extension:metadata field. crs key used geoarrow.point arrays; geodesic key used geoarrow.linestring geoarrow.polygon arrays. Practically chosen child arrays can passed functions validated independently (.e., without pass crs/geodesic values call stack extra arguments). Conceptually chosen keep metadata confined array relevant. geoarrow, can view decoded extension metadata using geoarrow_metadata(): serialized metadata looks like :","code":"geoarrow_metadata(geoarrow_schema_point(crs = \"OGC:CRS84\")) #> $crs #> [1] \"OGC:CRS84\" geoarrow_metadata(geoarrow_schema_linestring(geodesic = TRUE)) #> $geodesic #> [1] \"true\" geoarrow_schema_point(crs = \"OGC:CRS84\")$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.point\" #>  #> $`ARROW:extension:metadata` #>  [1] 01 00 00 00 03 00 00 00 63 72 73 09 00 00 00 4f 47 43 3a 43 52 53 38 34 geoarrow_schema_linestring(geodesic = TRUE)$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.linestring\" #>  #> $`ARROW:extension:metadata` #>  [1] 01 00 00 00 08 00 00 00 67 65 6f 64 65 73 69 63 04 00 00 00 74 72 75 65"},{"path":[]},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"metadata-1","dir":"Articles","previous_headings":"Points","what":"Metadata","title":"Geometry storage formats in geoarrow","text":"field-level metadata points geoarrow must contain extension type “geoarrow.point” extension metadata specifying optional coordinate reference system. coordinate reference system geoarrow always stored point array, used child array types.","code":"carray <- geoarrow_create(   wk::wkt(crs = \"EPSG:4326\"),   schema = geoarrow_schema_point() )  carray$schema$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.point\" #>  #> $`ARROW:extension:metadata` #>  [1] 01 00 00 00 03 00 00 00 63 72 73 09 00 00 00 45 50 53 47 3a 34 33 32 36 geoarrow_metadata(carray$schema) #> $crs #> [1] \"EPSG:4326\""},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"storage-type","dir":"Articles","previous_headings":"Points","what":"Storage type","title":"Geometry storage formats in geoarrow","text":"Points represented default geoarrow fixed-size list float64 (.e., double) values. Conceptually much like storing coordinates (row-major) matrix one row per feature one column per dimension. Points stored fixed-size list exactly one child named xy, xyz, xym, xyzm. width fixed-size list must 2, 3, 4, agree child name (e.g., child name xyzm, must fixed-size list size 4). child storage type must float64 now (although future child types like float32 decimal128 may supported). Points can also represented geoarrow struct. Conceptually much like storing points data frame one column per dimension (.e., x values stored next x values). Points stored struct must names correspond dimension (.e., x, y, z, m). name combinations allowed “xy”, “xyz”, “xym”, “xyzm”. child types must float64 now (although future child types like float32 decimal128 may supported). storage types points may supported future reference implementation : Dictionary-encoded point struct /fixed-width representation (may allow compact representation efficient querying polygon coverages shared vertices) S2 H3 identifiers (compact fast test containment) float decimal storage coordinate values (float lower precision adequate; decimal double precision inadequate). Future representations points reference implementation provide efficient methods access coordinates double/float64s. See C C++ development guide interface implemented two existing supported point types.","code":"carray <- geoarrow_create(   wk::wkt(c(\"POINT (0 1)\", \"POINT (2 3)\")),   schema = geoarrow_schema_point() ) narrow::from_narrow_array(carray, arrow::Array) #> FixedSizeListArray #> <fixed_size_list<xy: double>[2]> #> [ #>   [ #>     0, #>     1 #>   ], #>   [ #>     2, #>     3 #>   ] #> ] # interleaved xy values in one buffer carray$array_data$children[[1]]$buffers[[2]] #> [1] 0 1 2 3 carray <- geoarrow_create(   wk::wkt(c(\"POINT (0 1)\", \"POINT (2 3)\")),   schema = geoarrow_schema_point_struct() ) narrow::from_narrow_array(carray, arrow::Array) #> StructArray #> <struct<x: double, y: double>> #> -- is_valid: all not null #> -- child 0 type: double #>   [ #>     0, #>     2 #>   ] #> -- child 1 type: double #>   [ #>     1, #>     3 #>   ] # x values in one buffer carray$array_data$children[[1]]$buffers[[2]] #> [1] 0 2 # y values in another buffer carray$array_data$children[[2]]$buffers[[2]] #> [1] 1 3"},{"path":[]},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"metadata-2","dir":"Articles","previous_headings":"Linestrings","what":"Metadata","title":"Geometry storage formats in geoarrow","text":"field-level metadata linestrings geoarrow must contain extension type “geoarrow.linestring” extension metadata specifying optional “geodesic” flag (see parent ‘Metadata’ section ). coordinate reference system geoarrow always stored point array (.e., child array geoarrow.linestring).","code":"carray <- geoarrow_create(   wk::wkt(geodesic = TRUE),   schema = geoarrow_schema_linestring() )  carray$schema$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.linestring\" #>  #> $`ARROW:extension:metadata` #>  [1] 01 00 00 00 08 00 00 00 67 65 6f 64 65 73 69 63 04 00 00 00 74 72 75 65 geoarrow_metadata(carray$schema) #> $geodesic #> [1] \"true\""},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"storage-type-1","dir":"Articles","previous_headings":"Linestrings","what":"Storage type","title":"Geometry storage formats in geoarrow","text":"Linestrings stored list<vertices: <geoarrow.point>>. exact storage type geoarrow.point can vary described . Conceptually attaching buffer (int32_t) offsets exiting array points, offset points first vertex linestring.","code":"carray <- geoarrow_create(   wk::wkt(\"LINESTRING (1 2, 3 4)\"),   schema = geoarrow_schema_linestring() ) narrow::from_narrow_array(carray, arrow::Array) #> ListArray #> <list<vertices: fixed_size_list<xy: double>[2]>> #> [ #>   [ #>     [ #>       1, #>       2 #>     ], #>     [ #>       3, #>       4 #>     ] #>   ] #> ] # offsets for each linestring into the vertices array carray$array_data$buffers[[2]] #> [1] 0 2  # coordinates carray$array_data$children[[1]]$children[[1]]$buffers[[2]] #> [1] 1 2 3 4"},{"path":[]},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"metadata-3","dir":"Articles","previous_headings":"Polygons","what":"Metadata","title":"Geometry storage formats in geoarrow","text":"field-level metadata polygons geoarrow must contain extension type “geoarrow.polygon” extension metadata specifying optional “geodesic” flag (see parent ‘Metadata’ section ).","code":"carray <- geoarrow_create(   wk::wkt(geodesic = TRUE),   schema = geoarrow_schema_polygon() )  carray$schema$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.polygon\" #>  #> $`ARROW:extension:metadata` #>  [1] 01 00 00 00 08 00 00 00 67 65 6f 64 65 73 69 63 04 00 00 00 74 72 75 65 geoarrow_metadata(carray$schema) #> $geodesic #> [1] \"true\""},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"storage-type-2","dir":"Articles","previous_headings":"Polygons","what":"Storage type","title":"Geometry storage formats in geoarrow","text":"Linestrings stored list<rings: <list<vertices: <geoarrow.point>>>. exact storage type geoarrow.point can vary described . Conceptually attaching buffer (int32_t) offsets exiting array points, offset points first vertex linear ring. outer list contains offsets start polygon rings array. Just like WKB, rings must closed (.e., first coordinate must equal last coordinate).","code":"carray <- geoarrow_create(   wk::wkt(\"POLYGON ((0 0, 1 0, 0 1, 0 0))\"),   schema = geoarrow_schema_polygon() ) narrow::from_narrow_array(carray, arrow::Array) #> ListArray #> <list<rings: list<vertices: fixed_size_list<xy: double>[2]>>> #> [ #>   [ #>     [ #>       [ #>         0, #>         0 #>       ], #>       [ #>         1, #>         0 #>       ], #>       [ #>         0, #>         1 #>       ], #>       [ #>         0, #>         0 #>       ] #>     ] #>   ] #> ] # offsets for each polygon into the ring array carray$array_data$buffers[[2]] #> [1] 0 1  # offsets for each ring into the vertices array carray$array_data$children[[1]]$buffers[[2]] #> [1] 0 4  # coordinates carray$array_data$children[[1]]$children[[1]]$children[[1]]$buffers[[2]] #> [1] 0 0 1 0 0 1 0 0"},{"path":[]},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"metadata-4","dir":"Articles","previous_headings":"Collections","what":"Metadata","title":"Geometry storage formats in geoarrow","text":"Just like WKB, multipoints, multilinestrings, multipolygons, geometrycollections share common encoding different identifiers. Multipoint geometries ARROW:extension:name “geoarrow.multipoint” must contain child named “points” “geoarrow.point” extension type. Multilinestring geometries ARROW:extension:name “geoarrow.multilinestring” must contain child named “linestrings” “geoarrow.linestring” extension type. Multipolygon geometries ARROW:extension:name “geoarrow.multipolygon” must contain child named “polygons” “geoarrow.polygon” extension type. Geometry collections (.e., mixed arrays points, lines, polygons, multipoints, multipolygons, /geometry collections) currently supported. need communicate objects, use “geoarrow.wkb” extension type. future, support added unions (.e., child array sparse dense union points, lines, polygons, multipoints, multilinestrings, /multipolygons). Collections carry extension metadata (.e., CRS geodesic flags stay array relevant). metadata string omitted must empty (.e., 0 32-bit integer). (TODO: didn’t actually implement different extension names different types collections yet!!)","code":"carray <- geoarrow_create(   wk::wkt(geodesic = TRUE),   schema = geoarrow_schema_multipoint() )  carray$schema$metadata #> $`ARROW:extension:name` #> [1] \"geoarrow.multi\" #>  #> $`ARROW:extension:metadata` #> [1] 00 00 00 00"},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"storage-type-3","dir":"Articles","previous_headings":"Collections","what":"Storage type","title":"Geometry storage formats in geoarrow","text":"Multipoints stored list<points: <geoarrow.point>> Multilinestrings stored list<linestrings: <geoarrow.linestring>> Multipolygons stored list<polygons: <geoarrow.polygon>> Conceptually attaching buffer (int32_t) offsets existing array points, lines, polygons.","code":"carray <- geoarrow_create(   wk::wkt(\"MULTIPOINT (1 2, 3 4)\"),   schema = geoarrow_schema_multipoint() ) narrow::from_narrow_array(carray, arrow::Array) #> ListArray #> <list<points: fixed_size_list<xy: double>[2]>> #> [ #>   [ #>     [ #>       1, #>       2 #>     ], #>     [ #>       3, #>       4 #>     ] #>   ] #> ] # offsets for each multipoint into the points array carray$array_data$buffers[[2]] #> [1] 0 2  # coordinates carray$array_data$children[[1]]$children[[1]]$buffers[[2]] #> [1] 1 2 3 4"},{"path":"https://paleolimbot.github.io/geoarrow/articles/format.html","id":"relationship-to-well-known-binary","dir":"Articles","previous_headings":"","what":"Relationship to well-known binary","title":"Geometry storage formats in geoarrow","text":"physical layout logical types specified document designed align well-known binary (WKB), currently popular binary encoding used store shuffle geometries libraries. example, linestring WKB encoded : One byte describing endian (0x01 0x00) uint32_t describing geometry type dimensions. linestring 2 (XY), 1002 (XYZ), 2002 (XYM), 3002 (XYZM). uint32_t many vertices contained linestring buffer double containing coordinates coordinate values kept together. example, points (1 2, 3 4, 5 6) encoded [1, 2, 3, 4, 5, 6]. specification, store information WKB organized differently: struct ArrowSchema contains storage type metadata. default representation linestring stored list_of<vertices: fixed_list_of<xy: float64, 2>>, child name fixed list stores dimensions (xy) coordinates. int32_t buffer offsets start/end linestring points array. example includes one linestring, two numbers [0, 3]. length linestring can calculated subtracting (.e., offset_array[+ 1] - offset_array[]). double buffer containing coordinates coordinate values kept together (.e., [1, 2, 3, 4, 5, 6]). can learn buffers C structures geoarrow uses represent memory Arrow Columnar Format specification C Data interface specification. detailed guide iterating geometries C C++, see C C++ development guide.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/articles/geoarrow.html","id":"opening-a-dataset","dir":"Articles","previous_headings":"","what":"Opening a dataset","title":"Getting started with geoarrow","text":"geoarrow package provides functions simplify using write_dataset() open_dataset() datasets contain geospatial data encoded one columns. ’ll use arrow package, dplyr package, geoarrow. geoarrow package includes small test dataset places Denmark derived OpenStreetMap processed GeoFabrik. files written using arrow::write_dataset() hive-style partitioning (.e., folder name provides information value certain field files within folder). can preview dataset using head() geoarrow_collect_sf():","code":"library(arrow) library(dplyr) library(geoarrow)  places_folder <- system.file(\"denmark_osm/osm_places\", package = \"geoarrow\") list.files(places_folder, recursive = TRUE) #> [1] \"fclass=city/part-0.parquet\"             #> [2] \"fclass=farm/part-0.parquet\"             #> [3] \"fclass=hamlet/part-0.parquet\"           #> [4] \"fclass=island/part-0.parquet\"           #> [5] \"fclass=locality/part-0.parquet\"         #> [6] \"fclass=national_capital/part-0.parquet\" #> [7] \"fclass=suburb/part-0.parquet\"           #> [8] \"fclass=town/part-0.parquet\"             #> [9] \"fclass=village/part-0.parquet\" places <- open_dataset(places_folder) places %>%    head() %>%    geoarrow_collect_sf() #> Simple feature collection with 6 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 8.452075 ymin: 55.46649 xmax: 12.08192 ymax: 56.46175 #> Geodetic CRS:  WGS 84 #> # A tibble: 6 × 6 #>   osm_id    code population name     fclass            geometry #>   <chr>    <int>      <dbl> <chr>    <chr>          <POINT [°]> #> 1 21040334  1001      50781 Roskilde city   (12.08192 55.64335) #> 2 21040360  1001      72398 Esbjerg  city   (8.452075 55.46649) #> 3 26559154  1001      62687 Randers  city   (10.03715 56.46175) #> 4 26559170  1001      60508 Kolding  city     (9.47905 55.4895) #> 5 26559198  1001      56567 Vejle    city   (9.533324 55.70001) #> 6 26559213  1001     273077 Aarhus   city    (10.2134 56.14963)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/geoarrow.html","id":"querying-a-data-set","dir":"Articles","previous_headings":"","what":"Querying a data set","title":"Getting started with geoarrow","text":"Just like local data frame, can use dplyr verbs like fiilter(), mutate() summarise() subset manipulate data pulled R session. example, find places Denmark population greater 100,000 people, can : Geometry operators aren’t yet supported within Arrow compute engine, filtering transformation geometry columns must done beginning (.e., selecting files pass open_dataset()) end (.e., calling geoarrow_collect_sf()). (kind index dataset files exists, talk use )","code":"places %>%    filter(population > 100000) %>%    select(name, population, fclass, geometry) %>%    arrange(desc(population)) %>%    geoarrow_collect_sf() #> Simple feature collection with 5 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 9.921526 ymin: 55.39972 xmax: 12.57007 ymax: 57.04626 #> CRS:           NA #> # A tibble: 5 × 4 #>   name          population fclass                      geometry #>   <chr>              <dbl> <chr>                        <POINT> #> 1 København         613288 national_capital (12.57007 55.68672) #> 2 Aarhus            273077 city              (10.2134 56.14963) #> 3 Odense            178210 city             (10.38521 55.39972) #> 4 Aalborg           114194 city             (9.921526 57.04626) #> 5 Frederiksberg     102029 suburb           (12.53262 55.67802) capital <- places %>%    filter(name == \"København\") %>%    geoarrow_collect_sf()  # cities within 200 km of the capital places %>%    filter(fclass == \"city\") %>%    geoarrow_collect_sf() %>%    filter(     s2::s2_dwithin(geometry, capital, 200000)   ) #> Simple feature collection with 7 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 9.47905 ymin: 55.39972 xmax: 12.08192 ymax: 56.46175 #> CRS:           NA #> # A tibble: 7 × 6 #>   osm_id      code population name     fclass            geometry #> * <chr>      <int>      <dbl> <chr>    <chr>              <POINT> #> 1 21040334    1001      50781 Roskilde city   (12.08192 55.64335) #> 2 26559154    1001      62687 Randers  city   (10.03715 56.46175) #> 3 26559170    1001      60508 Kolding  city     (9.47905 55.4895) #> 4 26559198    1001      56567 Vejle    city   (9.533324 55.70001) #> 5 26559213    1001     273077 Aarhus   city    (10.2134 56.14963) #> 6 26559274    1001     178210 Odense   city   (10.38521 55.39972) #> 7 1368129781  1001      58646 Horsens  city   (9.844477 55.86117)"},{"path":"https://paleolimbot.github.io/geoarrow/articles/geoarrow.html","id":"reading-a-data-set-hosted-remotely","dir":"Articles","previous_headings":"","what":"Reading a data set hosted remotely","title":"Getting started with geoarrow","text":"(Wait properly formatted files public S3 bucket)","code":""},{"path":"https://paleolimbot.github.io/geoarrow/articles/geoarrow.html","id":"writing-a-data-set","dir":"Articles","previous_headings":"","what":"Writing a data set","title":"Getting started with geoarrow","text":"(Wait write_geoarrow_dataset() exists)","code":""},{"path":"https://paleolimbot.github.io/geoarrow/articles/geoarrow.html","id":"using-geoarrow_collect","dir":"Articles","previous_headings":"","what":"Using geoarrow_collect()","title":"Getting started with geoarrow","text":"point, used geoarrow_collect_sf(). probably want, since fantastic sf package feature-complete GIS designed work well GIS data data.frame form. want customize geometry columns converted R objects, can use geoarrow_collect() handler. example, want convert geometry geos::geos_geometry() directly without pivoting sf, can use handler = geos::geos_geometry_writer. large point data sets, can useful represent geometry wk::xy(), thin wrapper around data.frame(x = c(), y = c()). can create objects geometry columns using handler = wk::xy_writer:","code":"places %>%    head() %>%    geoarrow_collect(handler = geos::geos_geometry_writer) #> # A tibble: 6 × 6 #>   osm_id    code population name     fclass geometry                    #>   <chr>    <int>      <dbl> <chr>    <chr>  <geos_geom>                 #> 1 21040334  1001      50781 Roskilde city   <POINT (12.08192 55.64335)> #> 2 21040360  1001      72398 Esbjerg  city   <POINT (8.45208 55.46649)>  #> 3 26559154  1001      62687 Randers  city   <POINT (10.03715 56.46175)> #> 4 26559170  1001      60508 Kolding  city   <POINT (9.47905 55.4895)>   #> 5 26559198  1001      56567 Vejle    city   <POINT (9.53332 55.70001)>  #> 6 26559213  1001     273077 Aarhus   city   <POINT (10.2134 56.14963)> (places_xy <- places %>%    select(name, geometry) %>%    geoarrow_collect(handler = wk::xy_writer)) #> # A tibble: 7,255 × 2 #>    name               geometry             #>    <chr>              <wk_xy>              #>  1 Englebjerggård     (11.777372 55.20040) #>  2 Iglekærgård        (11.779017 55.19977) #>  3 Sibberup Østergård (11.800020 55.19469) #>  4 Boegård            (11.788049 55.18910) #>  5 Søbygård           (11.783189 55.18633) #>  6 Krogård            (11.777743 55.19016) #>  7 Korshøjgård        (11.815743 55.21096) #>  8 Dyssegård          (11.768147 55.20039) #>  9 Jernit             ( 9.922891 56.26500) #> 10 Styg Gårde         ( 8.393110 55.88779) #> # … with 7,245 more rows  xy <- as.data.frame(places_xy$geometry) head(xy$x) #> [1] 11.77737 11.77902 11.80002 11.78805 11.78319 11.77774"},{"path":"https://paleolimbot.github.io/geoarrow/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dewey Dunnington. Author, maintainer.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dunnington D (2022). geoarrow: Extension types geospatial data use 'Arrow'. R package version 0.0.0.9000, https://paleolimbot.github.io/geoarrow/.","code":"@Manual{,   title = {geoarrow: Extension types for geospatial data for use with 'Arrow'},   author = {Dewey Dunnington},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://paleolimbot.github.io/geoarrow/}, }"},{"path":"https://paleolimbot.github.io/geoarrow/index.html","id":"geoarrow","dir":"","previous_headings":"","what":"Extension types for geospatial data for use with Arrow","title":"Extension types for geospatial data for use with Arrow","text":"goal geoarrow prototype Arrow representations geometry. currently first-draft specification nothing used anything except entertainment value.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Extension types for geospatial data for use with Arrow","text":"can install development version GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"paleolimbot/geoarrow\")"},{"path":"https://paleolimbot.github.io/geoarrow/index.html","id":"write-and-write-to-parquet","dir":"","previous_headings":"","what":"Write and write to Parquet","title":"Extension types for geospatial data for use with Arrow","text":"exists prototyping , work things throw . Notably, sf objects work ---box. can also use arrow::open_dataset() geoarrow_collect_sf() use full power Arrow compute engine datasets one files:","code":"library(geoarrow)  nc <- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\")) write_geoarrow_parquet(nc, \"nc.parquet\") read_geoarrow_parquet_sf(\"nc.parquet\") #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #> # A tibble: 100 × 15 #>     AREA PERIMETER CNTY_ CNTY_ID NAME  FIPS  FIPSNO CRESS_ID BIR74 SID74 NWBIR74 #>    <dbl>     <dbl> <dbl>   <dbl> <chr> <chr>  <dbl>    <int> <dbl> <dbl>   <dbl> #>  1 0.114      1.44  1825    1825 Ashe  37009  37009        5  1091     1      10 #>  2 0.061      1.23  1827    1827 Alle… 37005  37005        3   487     0      10 #>  3 0.143      1.63  1828    1828 Surry 37171  37171       86  3188     5     208 #>  4 0.07       2.97  1831    1831 Curr… 37053  37053       27   508     1     123 #>  5 0.153      2.21  1832    1832 Nort… 37131  37131       66  1421     9    1066 #>  6 0.097      1.67  1833    1833 Hert… 37091  37091       46  1452     7     954 #>  7 0.062      1.55  1834    1834 Camd… 37029  37029       15   286     0     115 #>  8 0.091      1.28  1835    1835 Gates 37073  37073       37   420     0     254 #>  9 0.118      1.42  1836    1836 Warr… 37185  37185       93   968     4     748 #> 10 0.124      1.43  1837    1837 Stok… 37169  37169       85  1612     1     160 #> # … with 90 more rows, and 4 more variables: BIR79 <dbl>, SID79 <dbl>, #> #   NWBIR79 <dbl>, geometry <MULTIPOLYGON [°]> library(arrow) library(dplyr)  (query <- open_dataset(\"nc.parquet\") %>%   filter(grepl(\"^A\", NAME)) %>%   select(NAME, geometry) ) #> FileSystemDataset (query) #> NAME: string #> geometry: list<polygons: list<rings: list<vertices: fixed_size_list<xy: double>[2]>>> #>  #> * Filter: match_substring_regex(NAME, {pattern=\"^A\", ignore_case=false}) #> See $.data for the source Arrow object  query %>%    geoarrow_collect_sf() #> Simple feature collection with 6 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -82.07776 ymin: 34.80792 xmax: -79.23799 ymax: 36.58965 #> Geodetic CRS:  NAD27 #> # A tibble: 6 × 2 #>   NAME                                                                  geometry #>   <chr>                                                       <MULTIPOLYGON [°]> #> 1 Ashe      (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.… #> 2 Alleghany (((-81.23989 36.36536, -81.24069 36.37942, -81.26284 36.40504, -81.… #> 3 Avery     (((-81.94135 35.95498, -81.9614 35.93922, -81.94495 35.91861, -81.9… #> 4 Alamance  (((-79.24619 35.86815, -79.23799 35.83725, -79.54099 35.83699, -79.… #> 5 Alexander (((-81.10889 35.7719, -81.12728 35.78897, -81.1414 35.82332, -81.32… #> 6 Anson     (((-79.91995 34.80792, -80.32528 34.81476, -80.27512 35.19311, -80.…"},{"path":"https://paleolimbot.github.io/geoarrow/reference/as_geoarrow_vctr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create GeoArrow vectors — as_geoarrow_vctr","title":"Create GeoArrow vectors — as_geoarrow_vctr","text":"Create GeoArrow vectors","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/as_geoarrow_vctr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create GeoArrow vectors — as_geoarrow_vctr","text":"","code":"as_geoarrow_vctr(x, ..., schema = geoarrow_schema_default(x), strict = FALSE)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/as_geoarrow_vctr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create GeoArrow vectors — as_geoarrow_vctr","text":"x object convert GeoArrow representation. ... Passed wk::wk_handle() schema narrow::narrow_schema() use storage method. strict Use TRUE respect choices storage type, dimensions, CRS provided schema. default, FALSE, updates values match data.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/as_geoarrow_vctr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create GeoArrow vectors — as_geoarrow_vctr","text":"object class 'narrow_vctr_geoarrow_EXTENSION' narrow_vctr().","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow-package.html","id":null,"dir":"Reference","previous_headings":"","what":"geoarrow: Extension types for geospatial data for use with 'Arrow' — geoarrow-package","title":"geoarrow: Extension types for geospatial data for use with 'Arrow' — geoarrow-package","text":"Provides extension types conversions R-native object types 'Arrow' columnar types.","code":""},{"path":[]},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"geoarrow: Extension types for geospatial data for use with 'Arrow' — geoarrow-package","text":"Maintainer: Dewey Dunnington dewey@fishandwhistle.net (ORCID)","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create GeoArrow Arrays — geoarrow_create","title":"Create GeoArrow Arrays — geoarrow_create","text":"Create GeoArrow Arrays","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create GeoArrow Arrays — geoarrow_create","text":"","code":"geoarrow_create(   handleable,   ...,   schema = geoarrow_schema_default(handleable),   strict = FALSE )  # S3 method for default geoarrow_create(   handleable,   ...,   schema = geoarrow_schema_default(handleable),   strict = FALSE )  geoarrow_schema_default(handleable, point = geoarrow_schema_point())"},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create GeoArrow Arrays — geoarrow_create","text":"handleable object wk::wk_handle() method ... Passed wk::wk_handle() schema narrow::narrow_schema() use storage method. strict Use TRUE respect choices storage type, dimensions, CRS provided schema. default, FALSE, updates values match data. point point schema use coordinates","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create GeoArrow Arrays — geoarrow_create","text":"narrow::narrow_array()","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create GeoArrow Arrays — geoarrow_create","text":"","code":"geoarrow_create(wk::xy(1:5, 1:5)) #> <narrow_array +w:2[5]> #> - schema: #>   <narrow_schema '+w:2' at 0x559541a5b510> #>   - format: +w:2 #>   - name:  #>   - flags: nullable #>   - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.point\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #>   - dictionary: NULL #>   - children[1]: #>     <narrow_schema 'g' at 0x55954465cd00> #>     - format: g #>     - name: xy #>     - flags: nullable #>     - metadata:  list() #>     - dictionary: NULL #>     - children[0]: #> - array_data: #>   <narrow_array_data at 0x5595432c2af0> #>   - length: 5 #>   - null_count: 0 #>   - offset: 0 #>   - buffers[1]: List of 1 #>     $ : NULL #>   - dictionary: NULL #>   - children[1]: #>     <narrow_array_data at 0x5595446e4a10> #>     - length: 10 #>     - null_count: 0 #>     - offset: 0 #>     - buffers[2]: List of 2 #>       $ : NULL #>       $ : num [1:10] 1 1 2 2 3 3 4 4 5 5 #>     - dictionary: NULL #>     - children[0]:"},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Arrow extension type  metadata — geoarrow_metadata","title":"Extract Arrow extension type  metadata — geoarrow_metadata","text":"Extract Arrow extension type  metadata","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Arrow extension type  metadata — geoarrow_metadata","text":"","code":"geoarrow_metadata(schema)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Arrow extension type  metadata — geoarrow_metadata","text":"schema narrow_schema()","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Arrow extension type  metadata — geoarrow_metadata","text":"list()","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Arrow extension type  metadata — geoarrow_metadata","text":"","code":"geoarrow_metadata(geoarrow_schema_point(crs = \"OGC:CRS84\")) #> $crs #> [1] \"OGC:CRS84\" #>"},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_schema_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Create low-level Arrow schemas — geoarrow_schema_point","title":"Create low-level Arrow schemas — geoarrow_schema_point","text":"schemas used basis column types Apache Arrow","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_schema_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create low-level Arrow schemas — geoarrow_schema_point","text":"","code":"geoarrow_schema_point(name = \"\", dim = \"xy\", crs = NULL, format_coord = \"g\")  geoarrow_schema_point_struct(   name = \"\",   dim = \"xy\",   crs = NULL,   format_coord = \"g\" )  geoarrow_schema_linestring(   name = \"\",   geodesic = FALSE,   point = geoarrow_schema_point() )  geoarrow_schema_polygon(   name = \"\",   geodesic = FALSE,   point = geoarrow_schema_point() )  geoarrow_schema_multipoint(   child,   name = \"\",   dim = \"xy\",   crs = NULL,   format_coord = \"g\" )  geoarrow_schema_multilinestring(   child,   name = \"\",   geodesic = FALSE,   point = geoarrow_schema_point() )  geoarrow_schema_multipolygon(   child,   name = \"\",   geodesic = FALSE,   point = geoarrow_schema_point() )  geoarrow_schema_multi(child, name = \"\")  geoarrow_schema_wkb(name = \"\", format = \"z\", crs = NULL, geodesic = FALSE)  geoarrow_schema_wkt(name = \"\", format = \"u\", crs = NULL, geodesic = FALSE)  geoarrow_schema_geojson(name = \"\", format = \"u\", crs = NULL)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_schema_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create low-level Arrow schemas — geoarrow_schema_point","text":"name optional name dim string one character per dimension. string must one xy, xyz, xym, xyzm. crs length-one character representation CRS. WKT2 representation recommended complete way encode information; however, string can recognized PROJ command-line utility (e.g., \"OGC:CRS84\"). format_coord format floating point coordinate storage. can \"f\" (float/float32) \"g\" (double/float64). geodesic Use TRUE assert edges interpolated using shortest geodesic path (great circle sphere). point point schema use coordinates child child schema use single-type (multi) collection format custom storage format","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_schema_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create low-level Arrow schemas — geoarrow_schema_point","text":"narrow_schema().","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/geoarrow_schema_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create low-level Arrow schemas — geoarrow_schema_point","text":"","code":"geoarrow_schema_point() #> <narrow_schema '+w:2' at 0x55954172ca20> #> - format: +w:2 #> - name:  #> - flags: nullable #> - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.point\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #> - dictionary: NULL #> - children[1]: #>   <narrow_schema 'g' at 0x55953c584320> #>   - format: g #>   - name: xy #>   - flags: nullable #>   - metadata:  list() #>   - dictionary: NULL #>   - children[0]: geoarrow_schema_linestring() #> <narrow_schema '+l' at 0x559541949ae0> #> - format: +l #> - name:  #> - flags: nullable #> - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.linestring\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #> - dictionary: NULL #> - children[1]: #>   <narrow_schema '+w:2' at 0x55953f54a7a0> #>   - format: +w:2 #>   - name: vertices #>   - flags: nullable #>   - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.point\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #>   - dictionary: NULL #>   - children[1]: #>     <narrow_schema 'g' at 0x55954205a840> #>     - format: g #>     - name: xy #>     - flags: nullable #>     - metadata:  list() #>     - dictionary: NULL #>     - children[0]: geoarrow_schema_polygon() #> <narrow_schema '+l' at 0x55953f6a8740> #> - format: +l #> - name:  #> - flags: nullable #> - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.polygon\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #> - dictionary: NULL #> - children[1]: #>   <narrow_schema '+l' at 0x559541372de0> #>   - format: +l #>   - name: rings #>   - flags: nullable #>   - metadata:  list() #>   - dictionary: NULL #>   - children[1]: #>     <narrow_schema '+w:2' at 0x559542064dd0> #>     - format: +w:2 #>     - name: vertices #>     - flags: nullable #>     - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.point\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #>     - dictionary: NULL #>     - children[1]: #>       <narrow_schema 'g' at 0x55954147dab0> #>       - format: g #>       - name: xy #>       - flags: nullable #>       - metadata:  list() #>       - dictionary: NULL #>       - children[0]: geoarrow_schema_multi(geoarrow_schema_point()) #> <narrow_schema '+l' at 0x559541f4fc90> #> - format: +l #> - name:  #> - flags: nullable #> - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.multi\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #> - dictionary: NULL #> - children[1]: #>   <narrow_schema '+w:2' at 0x55953efe3a10> #>   - format: +w:2 #>   - name: points #>   - flags: nullable #>   - metadata: List of 2 #>   $ ARROW:extension:name    : chr \"geoarrow.point\" #>   $ ARROW:extension:metadata: raw [1:4] 00 00 00 00 #>   - dictionary: NULL #>   - children[1]: #>     <narrow_schema 'g' at 0x5595436f4570> #>     - format: g #>     - name: xy #>     - flags: nullable #>     - metadata:  list() #>     - dictionary: NULL #>     - children[0]:"},{"path":"https://paleolimbot.github.io/geoarrow/reference/read_geoarrow_parquet.html","id":null,"dir":"Reference","previous_headings":"","what":"Read geometry from Apache Parquet files — read_geoarrow_parquet","title":"Read geometry from Apache Parquet files — read_geoarrow_parquet","text":"Read geometry Apache Parquet files","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/read_geoarrow_parquet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read geometry from Apache Parquet files — read_geoarrow_parquet","text":"","code":"read_geoarrow_parquet(   file,   ...,   as_data_frame = TRUE,   handler = NULL,   metadata = NULL )  read_geoarrow_feather(   file,   ...,   as_data_frame = TRUE,   handler = NULL,   metadata = NULL )  read_geoarrow_ipc_stream(   file,   ...,   as_data_frame = TRUE,   handler = NULL,   metadata = NULL )  read_geoarrow_parquet_sf(file, ...)  read_geoarrow_feather_sf(file, ...)  geoarrow_collect_sf(x, ..., metadata = NULL)  geoarrow_collect(x, ..., handler = NULL, metadata = NULL)  # S3 method for Table geoarrow_collect(x, ..., handler = NULL, metadata = NULL)  # S3 method for RecordBatch geoarrow_collect(x, ..., handler = NULL, metadata = NULL)  # S3 method for RecordBatchReader geoarrow_collect(x, trans = identity, ..., handler = NULL, metadata = NULL)  # S3 method for Dataset geoarrow_collect(x, trans = identity, ..., handler = NULL, metadata = NULL)  # S3 method for arrow_dplyr_query geoarrow_collect(x, ..., handler = NULL, metadata = NULL)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/read_geoarrow_parquet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read geometry from Apache Parquet files — read_geoarrow_parquet","text":"file file InputStream read; passed arrow::read_parquet(), arrow::read_feather(), arrow::read_ipc_stream(). ... Arguments passed arrow::write_parquet sink string file path, URI, OutputStream, path file system (SubTreeFileSystem) chunk_size many rows data write disk . directly corresponds many rows row group parquet. NULL, best guess made optimal size (based number columns number rows), though data fewer 250 million cells (rows x cols), total number rows used. version parquet version, \"1.0\" \"2.0\". Default \"1.0\". Numeric values coerced character. compression compression algorithm. Default \"snappy\". See details. compression_level compression level. Meaning depends compression algorithm use_dictionary Specify use dictionary encoding. Default TRUE write_statistics Specify write statistics. Default TRUE data_page_size Set target threshold approximate encoded size data pages within column chunk (bytes). Default 1 MiB. use_deprecated_int96_timestamps Write timestamps INT96 Parquet format. Default FALSE. coerce_timestamps Cast timestamps particular resolution. Can NULL, \"ms\" \"us\". Default NULL (casting) allow_truncated_timestamps Allow loss data coercing timestamps particular resolution. E.g. microsecond nanosecond data lost coercing \"ms\", raise exception properties ParquetWriterProperties object, used instead options enumerated function's signature. Providing properties argument deprecated; need assemble ParquetWriterProperties outside write_parquet(), use ParquetFileWriter instead. arrow_properties ParquetArrowWriterProperties object. Like properties, argument deprecated. as_data_frame Use FALSE return arrow::Table instead data.frame. handler wk handler use .data.frame TRUE geometry columns. metadata Optional metadata include override metadata available file. x object collect data.frame, converting geometry columns according handler. trans function applied chunk collected data frame.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/read_geoarrow_parquet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read geometry from Apache Parquet files — read_geoarrow_parquet","text":"result arrow::read_parquet(), geometry columns processed according handler.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/wk_handle.narrow_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle Arrow arrays — wk_handle.narrow_array","title":"Handle Arrow arrays — wk_handle.narrow_array","text":"Handle Arrow arrays","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/wk_handle.narrow_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle Arrow arrays — wk_handle.narrow_array","text":"","code":"# S3 method for narrow_array wk_handle(handleable, handler, ...)  # S3 method for narrow_array_stream wk_handle(   handleable,   handler,   ...,   geoarrow_schema = narrow::narrow_array_stream_get_schema(handleable),   geoarrow_n_features = NA_integer_ )  # S3 method for narrow_vctr_geoarrow wk_handle(handleable, handler, ...)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/wk_handle.narrow_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle Arrow arrays — wk_handle.narrow_array","text":"handleable geometry vector (e.g., wkb(), wkt(), xy(), rct(), sf::st_sfc()) wk_handle() defined. handler wk_handler object. ... Passed wk_handle() method. geoarrow_schema Override schema array stream (e.g., provide geo metadata). geoarrow_n_features Manually specify number features reading stream value known (NA_integer ).","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/wk_handle.narrow_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle Arrow arrays — wk_handle.narrow_array","text":"result handler","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/write_geoarrow_parquet.html","id":null,"dir":"Reference","previous_headings":"","what":"Write geometry as Apache Parquet files — write_geoarrow_parquet","title":"Write geometry as Apache Parquet files — write_geoarrow_parquet","text":"Write geometry Apache Parquet files","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/write_geoarrow_parquet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write geometry as Apache Parquet files — write_geoarrow_parquet","text":"","code":"write_geoarrow_parquet(handleable, ..., schema = NULL, strict = FALSE)  write_geoarrow_feather(handleable, ..., schema = NULL, strict = FALSE)  write_geoarrow_ipc_stream(handleable, ..., schema = NULL, strict = FALSE)"},{"path":"https://paleolimbot.github.io/geoarrow/reference/write_geoarrow_parquet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write geometry as Apache Parquet files — write_geoarrow_parquet","text":"handleable object wk::wk_handle() method ... Arguments passed arrow::write_parquet x data.frame, RecordBatch, Table sink string file path, URI, OutputStream, path file system (SubTreeFileSystem) chunk_size many rows data write disk . directly corresponds many rows row group parquet. NULL, best guess made optimal size (based number columns number rows), though data fewer 250 million cells (rows x cols), total number rows used. version parquet version, \"1.0\" \"2.0\". Default \"1.0\". Numeric values coerced character. compression compression algorithm. Default \"snappy\". See details. compression_level compression level. Meaning depends compression algorithm use_dictionary Specify use dictionary encoding. Default TRUE write_statistics Specify write statistics. Default TRUE data_page_size Set target threshold approximate encoded size data pages within column chunk (bytes). Default 1 MiB. use_deprecated_int96_timestamps Write timestamps INT96 Parquet format. Default FALSE. coerce_timestamps Cast timestamps particular resolution. Can NULL, \"ms\" \"us\". Default NULL (casting) allow_truncated_timestamps Allow loss data coercing timestamps particular resolution. E.g. microsecond nanosecond data lost coercing \"ms\", raise exception properties ParquetWriterProperties object, used instead options enumerated function's signature. Providing properties argument deprecated; need assemble ParquetWriterProperties outside write_parquet(), use ParquetFileWriter instead. arrow_properties ParquetArrowWriterProperties object. Like properties, argument deprecated. schema narrow::narrow_schema() use storage method. strict Use TRUE respect choices storage type, dimensions, CRS provided schema. default, FALSE, updates values match data.","code":""},{"path":"https://paleolimbot.github.io/geoarrow/reference/write_geoarrow_parquet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write geometry as Apache Parquet files — write_geoarrow_parquet","text":"result arrow::write_parquet(), invisibly","code":""}]
