---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(arrow)

# hack to view the pretty Arrow C++ printing of a C schema
pretty_type <- function(x) {
  carrow::from_carrow_array(list(schema = x), arrow:::DataType)
}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# geoarrow

<!-- badges: start -->
[![R-CMD-check](https://github.com/paleolimbot/geoarrow/workflows/R-CMD-check/badge.svg)](https://github.com/paleolimbot/geoarrow/actions)
[![Codecov test coverage](https://codecov.io/gh/paleolimbot/geoarrow/branch/master/graph/badge.svg)](https://codecov.io/gh/paleolimbot/geoarrow?branch=master)
<!-- badges: end -->

The goal of geoarrow is to prototype Arrow representations of geometry. This is currently a [first-draft specification](https://github.com/jorisvandenbossche/geo-arrow-spec/blob/geo-arrow-format-initial/format.md) and nothing here should be used for anything except entertainment value. 

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("paleolimbot/geoarrow")
```

## Type examples

```{r}
library(geoarrow)
```

First, specs for the kind of data people are already using:

```{r}
pretty_type(geoarrow_schema_wkb())
pretty_type(geoarrow_schema_wkt())
pretty_type(geoarrow_schema_geojson())
```

...but also Arrow-native forms that don't need to be parsed:

```{r example}
pretty_type(geoarrow_schema_point())
pretty_type(geoarrow_schema_point_float32())
pretty_type(geoarrow_schema_linestring())
pretty_type(geoarrow_schema_polygon())
pretty_type(geoarrow_schema_multi(geoarrow_schema_point()))
pretty_type(geoarrow_schema_multi(geoarrow_schema_linestring()))
pretty_type(geoarrow_schema_multi(geoarrow_schema_polygon()))
# (I can't get dense or sparse unions to import to the Arrow R package at the moment
# but that's how collections could be stored)
```

This setup gives considerable flexibility as to the coordinate storage format (with a reasonable default whose usage could be mandated for a particular library). For example, s2 cell IDs (a 64-bit integer) could be used for points using the same linestring type.

In addition to nested list types, this package also defines "flat" types that can be streamed without waiting for a feature boundary. This is helpful for algorithms that don't need all the coordinates in memory at once or for streaming very large geometries over a network connection.

```{r}
pretty_type(geoarrow_schema_flat_linestring())
pretty_type(geoarrow_schema_flat_polygon())
pretty_type(geoarrow_schema_flat_multi(geoarrow_schema_point()))
```

The schemas here use column-level extension types and extension metadata to encode dimension names, CRS information, and a flag to specify that edges should be considered ellipsoidal rather than Cartesian.

```{r}
schema <- geoarrow_schema_linestring(ellipsoidal = TRUE)
schema$metadata[["ARROW:extension:name"]]
geoarrow_metadata(schema)
geoarrow_metadata(schema$children[[1]])
```
